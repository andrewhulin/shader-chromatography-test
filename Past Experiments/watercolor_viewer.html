<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Watercolor Chromatography Shader</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1612; overflow: hidden; height: 100vh; display: flex; align-items: center; justify-content: center; }
  canvas { display: block; width: 100vw; height: 100vh; }
  .ui {
    position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 10px; z-index: 10;
  }
  .ui button {
    background: rgba(255,252,245,0.88); border: 1px solid rgba(180,160,130,0.3);
    padding: 9px 22px; border-radius: 20px; font: 13px/1 'Georgia', serif;
    color: #4a3a28; cursor: pointer; backdrop-filter: blur(12px);
    transition: all 0.25s; letter-spacing: 0.3px;
    box-shadow: 0 2px 16px rgba(0,0,0,0.06);
  }
  .ui button:hover { background: #fff; transform: translateY(-1px); box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
  .info {
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    font: 11px/1.5 'Georgia', serif; color: rgba(120,100,80,0.5);
    letter-spacing: 1px; text-transform: uppercase;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="info">Watercolor Chromatography</div>
<div class="ui">
  <button onclick="regen()">New Composition</button>
  <button onclick="pause()">Pause</button>
</div>

<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: true });
if (!gl) { document.body.innerHTML = '<p style="color:#fff;padding:40px">WebGL not supported</p>'; }

// ── Shader source (embedded from .frag) ──

const VERT = `
attribute vec2 pos;
void main() { gl_Position = vec4(pos, 0.0, 1.0); }
`;

const FRAG = `
#ifdef GL_ES
precision highp float;
#endif

uniform vec3  iResolution;
uniform float iTime;
uniform vec4  iMouse;

#define PAPER_COLOR     vec3(0.988, 0.973, 0.941)
#define NUM_FLOWERS     5
#define NUM_SPLOTCHES   7
#define FBM_OCTAVES     5
#define LACUNARITY      2.0
#define GAIN            0.5
#define WARP_STRENGTH   4.0

vec2 hash2(vec2 p) {
    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
}
float hash1(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
float hash1f(float p) { return fract(sin(p * 127.1) * 43758.5453); }

vec3 noised(vec2 p) {
    vec2 i = floor(p), f = fract(p);
    vec2 u = f*f*(3.0-2.0*f), du = 6.0*f*(1.0-f);
    float a = hash1(i), b = hash1(i+vec2(1,0)), c = hash1(i+vec2(0,1)), d = hash1(i+vec2(1,1));
    float k0=a, k1=b-a, k2=c-a, k4=a-b-c+d;
    return vec3(k0+k1*u.x+k2*u.y+k4*u.x*u.y, du*(vec2(k1,k2)+k4*u.yx));
}
float noise(vec2 p) { return noised(p).x; }

const mat2 ROT = mat2(0.80, 0.60, -0.60, 0.80);

float fbm(vec2 p) {
    float s=0.0, a=0.5, f=1.0;
    for(int i=0;i<FBM_OCTAVES;i++) { s+=a*noise(p*f); p=ROT*p; f*=LACUNARITY; a*=GAIN; }
    return s;
}
float turbulence(vec2 p) {
    float s=0.0, a=0.5, f=1.0;
    for(int i=0;i<FBM_OCTAVES;i++) { s+=a*abs(noise(p*f)*2.0-1.0); p=ROT*p; f*=LACUNARITY; a*=GAIN; }
    return s;
}

float domainWarp(vec2 p, out vec2 q, out vec2 r) {
    q = vec2(fbm(p), fbm(p+vec2(5.2,1.3)));
    r = vec2(fbm(p+WARP_STRENGTH*q+vec2(1.7,9.2)), fbm(p+WARP_STRENGTH*q+vec2(8.3,2.8)));
    return fbm(p+WARP_STRENGTH*r);
}

float sdCircle(vec2 p, float r) { return length(p)-r; }

float smin(float a, float b, float k) {
    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
    return mix(b,a,h)-k*h*(1.0-h);
}

float organicPetal(vec2 p, float numPetals, float size, float seed) {
    float r = length(p), theta = atan(p.y, p.x);
    float petalR = size*(0.5+0.5*cos(numPetals*theta));
    vec2 nc = vec2(cos(theta),sin(theta))*2.0+seed;
    petalR += fbm(nc)*size*0.15;
    petalR *= (0.8+0.4*noise(vec2(theta*0.5+seed, seed*1.3)));
    return r - petalR;
}

float paperTexture(vec2 uv) {
    return fbm(uv*60.0)*0.5 + noise(uv*180.0)*0.3 + turbulence(uv*120.0)*0.2;
}

float worley(vec2 p) {
    vec2 i=floor(p), f=fract(p); float md=1.0;
    for(int y=-1;y<=1;y++) for(int x=-1;x<=1;x++) {
        vec2 nb=vec2(float(x),float(y));
        vec2 pt=hash2(i+nb)*0.5+0.5;
        md=min(md, length(nb+pt-f));
    }
    return md;
}

float granulation(vec2 uv, float density, float gran) {
    float h = paperTexture(uv);
    return (1.0-h*gran)*density;
}

vec3 chromatography(vec2 uv, vec3 p1, vec3 p2, float amt, float seed) {
    vec2 flow = vec2(fbm(uv*3.0+seed), fbm(uv*3.0+vec2(7.1,3.3)+seed));
    float heavy = fbm(uv*4.0+seed*0.7)*0.3;
    float light = fbm((uv+flow*amt)*2.0+seed*1.3);
    float mf = smoothstep(0.3,0.7, light-heavy*0.5);
    return mix(p1, p2, mf);
}

vec3 glazeLayer(vec3 paper, vec3 pigment, float density) {
    vec3 c = pigment;
    vec3 r = c-(c-c*c)*(density-1.0);
    return mix(paper, r, clamp(density,0.0,1.0));
}

vec4 computeWash(vec2 uv, vec2 center, float size, float numPetals, float seed,
                  vec3 pig1, vec3 pig2, float opacity, float bleedW, float edgeDk,
                  float gran, float chromaAmt) {
    vec2 local = uv - center;
    float dist = organicPetal(local, numPetals, size, seed);
    dist -= fbm(uv*8.0+seed)*size*0.18;

    float innerEdge = smoothstep(0.0, -size*0.06, dist);
    float outerBleed = smoothstep(bleedW*size, 0.0, dist);

    float ew = size*0.04*(1.0+fbm(uv*12.0+seed*2.0)*0.6);
    float edgeDark = smoothstep(ew, 0.0, abs(dist))*edgeDk;

    vec3 pigColor = chromatography(uv, pig1, pig2, chromaAmt, seed);

    float granMod = mix(1.0, granulation(uv,1.0,gran), gran*0.4);
    float centerDist = length(local)/size;
    float loadVar = (1.0-centerDist*0.3)*(0.85+0.15*noise(uv*15.0+seed));

    float alpha = mix(outerBleed*0.3, innerEdge, innerEdge);
    alpha *= opacity*loadVar*granMod;
    alpha += edgeDark*opacity*0.7;
    alpha = clamp(alpha, 0.0, 1.0);

    pigColor = mix(pigColor, pigColor*0.55, edgeDark);
    return vec4(pigColor, alpha);
}

vec4 computeSplotch(vec2 uv, vec2 center, float size, vec3 color, float seed) {
    vec2 local = uv - center;
    float dist = sdCircle(local, size);
    vec2 q, r;
    float w = domainWarp(local*3.0/size+seed, q, r);
    dist += w*size*0.25;
    dist -= fbm(uv*10.0+seed*3.0)*size*0.12;

    float edge = smoothstep(size*0.05, -size*0.02, dist);
    float bloom = smoothstep(size*0.15, 0.0, dist)*0.15;
    float scallop = smoothstep(size*0.02, 0.0, abs(dist))*0.4;

    float alpha = edge*0.12+bloom+scallop;
    alpha *= (0.7+0.3*turbulence(uv*8.0+seed));

    vec3 sc = mix(color, color*0.6, length(q)*0.5);
    sc = mix(sc, color*1.2, r.y*0.3);
    return vec4(clamp(sc,0.0,1.0), clamp(alpha,0.0,1.0));
}

float stemLine(vec2 uv, vec2 a, vec2 b, float width, float seed) {
    vec2 pa=uv-a, ba=b-a;
    float t=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);
    float d=length(pa-ba*t);
    d += fbm(uv*30.0+seed)*width*0.5;
    float taper = smoothstep(0.0,0.1,t)*smoothstep(1.0,0.85,t);
    return smoothstep(width*taper, width*taper*0.3, d);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord/iResolution.xy;
    float aspect = iResolution.x/iResolution.y;
    vec2 uvA = vec2(uv.x*aspect, uv.y);

    float t = iTime*0.03;
    float paper = paperTexture(uv);
    float pw = worley(uv*80.0);
    vec3 result = PAPER_COLOR - vec3(paper*0.03+pw*0.015);
    result += vec3(0.005,0.002,-0.003)*fbm(uv*5.0+t);

    float pp = floor(t*0.5);
    float ps = hash1f(pp*7.13);

    vec3 pink  = vec3(0.85,0.28,0.38)+0.1*sin(vec3(ps,ps*2.1,ps*3.7));
    vec3 coral = vec3(0.92,0.50,0.28)+0.08*sin(vec3(ps*1.3,ps*0.7,ps*2.9));
    vec3 mauve = vec3(0.55,0.25,0.48)+0.1*sin(vec3(ps*2.3,ps*1.1,ps*0.5));
    vec3 sage  = vec3(0.25,0.48,0.32)+0.06*sin(vec3(ps*0.9,ps*3.1,ps*1.7));
    vec3 gold  = vec3(0.90,0.72,0.25)+0.05*sin(vec3(ps*1.7,ps*0.3,ps*2.1));
    vec3 ink   = vec3(0.12,0.08,0.06);

    // Splotches
    for(int i=0;i<NUM_SPLOTCHES;i++) {
        float fi=float(i);
        float s=hash1f(fi*31.7+pp);
        vec2 ctr=vec2(hash1f(fi*13.3+pp)*aspect, hash1f(fi*23.1+pp));
        float sz=0.12+hash1f(fi*41.3+pp)*0.2;
        vec3 col = (fi<1.0)?pink:(fi<2.0)?coral:(fi<3.0)?mauve:(fi<4.0)?sage:gold;
        vec4 sp = computeSplotch(uvA, ctr, sz, col, s*100.0);
        result = mix(result, glazeLayer(PAPER_COLOR, sp.rgb, 1.5), sp.a*0.5);
    }

    // Flowers
    for(int i=0;i<NUM_FLOWERS;i++) {
        float fi=float(i);
        float s=hash1f(fi*17.3+pp);
        vec2 ctr=vec2(0.2+hash1f(fi*7.1+pp)*(aspect-0.4), 0.2+hash1f(fi*11.3+pp)*0.6);
        float sz=0.08+hash1f(fi*29.7+pp)*0.12;
        float np=3.0+floor(hash1f(fi*37.1+pp)*4.0);
        vec3 p1=(fi<1.0)?pink:(fi<2.0)?coral:(fi<3.0)?mauve:(fi<4.0)?sage:gold;
        vec3 p2=(fi<1.0)?mauve:(fi<2.0)?gold:(fi<3.0)?pink:(fi<4.0)?vec3(0.45,0.55,0.15):coral;
        float op=0.3+fi*0.1, bw=0.08+hash1f(fi*43.1)*0.07;
        float ed=0.5+hash1f(fi*53.1)*0.4, gr=hash1f(fi*61.3)*0.8;
        float ca=0.03+hash1f(fi*67.1)*0.06;

        vec4 w = computeWash(uvA, ctr, sz, np, s*100.0, p1, p2, op, bw, ed, gr, ca);
        result = mix(result, glazeLayer(result, w.rgb, 1.0+w.a), w.a);
    }

    // Stems
    for(int i=0;i<3;i++) {
        float fi=float(i), s=hash1f(fi*71.3+pp);
        vec2 ss=vec2(0.3+s*(aspect-0.6), 0.1+hash1f(fi*79.1+pp)*0.2);
        vec2 se=ss+vec2((hash1f(fi*83.3+pp)-0.5)*0.3, 0.3+hash1f(fi*89.1+pp)*0.4);
        result = mix(result, ink, stemLine(uvA,ss,se,0.003,s*100.0)*0.85);
        vec2 bp=mix(ss,se,0.5+s*0.3);
        vec2 be=bp+vec2((s-0.5)*0.15, 0.05+s*0.08);
        result = mix(result, ink, stemLine(uvA,bp,be,0.002,s*200.0)*0.7);
    }

    // Flower centers
    for(int i=0;i<NUM_FLOWERS;i++) {
        float fi=float(i);
        vec2 ctr=vec2(0.2+hash1f(fi*7.1+pp)*(aspect-0.4), 0.2+hash1f(fi*11.3+pp)*0.6);
        float ds=0.008+hash1f(fi*97.1)*0.006;
        float d=sdCircle(uvA-ctr, ds);
        d += fbm((uvA-ctr)*80.0+fi)*ds*0.8;
        float dt=smoothstep(ds*0.3, -ds*0.2, d);
        result = mix(result, ink*(0.8+0.2*noise(uvA*40.0+fi)), dt*0.9);
    }

    // Final paper overlay
    float fg = paperTexture(uv*1.1+0.5);
    float pp2 = clamp(1.0-length(result-PAPER_COLOR)*3.0, 0.0, 1.0);
    result += vec3(fg*0.02)*(1.0-pp2);

    vec2 vc = uv-0.5;
    result *= 1.0-dot(vc,vc)*0.3;

    fragColor = vec4(clamp(result,0.0,1.0), 1.0);
}

void main() {
    vec4 c;
    mainImage(c, gl_FragCoord.xy);
    gl_FragColor = c;
}
`;

// ── WebGL Setup ──

let program, timeUniform, resUniform, mouseUniform;
let startTime = performance.now();
let running = true;
let animId;

function resize() {
    const dpr = Math.min(window.devicePixelRatio, 2);
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    gl.viewport(0, 0, canvas.width, canvas.height);
}

function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
        return null;
    }
    return s;
}

function init() {
    resize();
    const vs = compile(gl.VERTEX_SHADER, VERT);
    const fs = compile(gl.FRAGMENT_SHADER, FRAG);
    program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);

    // Full-screen quad
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    const pos = gl.getAttribLocation(program, 'pos');
    gl.enableVertexAttribArray(pos);
    gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);

    timeUniform = gl.getUniformLocation(program, 'iTime');
    resUniform = gl.getUniformLocation(program, 'iResolution');
    mouseUniform = gl.getUniformLocation(program, 'iMouse');
}

function render() {
    if (!running) return;
    const t = (performance.now() - startTime) / 1000.0;
    gl.uniform1f(timeUniform, t);
    gl.uniform3f(resUniform, canvas.width, canvas.height, 1.0);
    gl.uniform4f(mouseUniform, 0, 0, 0, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    animId = requestAnimationFrame(render);
}

function regen() {
    startTime = performance.now() - Math.random() * 200000;
}

function pause() {
    running = !running;
    document.querySelector('.ui button:nth-child(2)').textContent = running ? 'Pause' : 'Play';
    if (running) render();
}

window.addEventListener('resize', resize);
init();
render();
</script>
</body>
</html>
